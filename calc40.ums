.section data
.zero r0
.temps r6, r7

jumptable:
    .space 256
    
.section init
r5 := jumptable
r4 := jumptable + 256

// m[r0][x] == input_err for all x s.t. r5 <= x < r4
// continue to jumptable_setup_digits
jumptable_set_inputerr:
    m[r0][r5] := input_err
    r5 := r5 + 1
    if (r5 == r4) goto jumptable_setup_digits using r3
    goto jumptable_set_inputerr 

// m[r0][x] == digit for all x s.t. '0' <= x <= '9'
jumptable_setup_digits:
    r5 := jumptable + '0'
    r4 := jumptable + '9'
// similar but jumptable+x where r5 <= x <= jumptable +'9'
jumptable_set_digits:     
    m[r0][r5] := digit
    r5 := r5 + 1
    if (r5 <=s r4) goto jumptable_set_digits using r3

// initializing all the commands in the jumptable 
.section init
m[r0][jumptable + ' '] := space
.section text
space:
    r4 := 0         // calculator enters the waiting stage
    goto calculator
    
.section init
m[r0][jumptable + '\n'] := newline
.section text
newline:
    push r1 on stack r2
    r4 := r3        // making a copy of the value stack pointer
    newline_loop:
        // reached bottom of stack
        if (r4 == value_stack) goto newline_end using r5
        r5 := m[r0][r4]
        push r5 on stack r2        // value to be printed
        output ">>> "
        goto print linking r1
        output "\n"
        r4 := r4 + 1                // moving up in value stack
        goto newline_loop
    newline_end:
        r4 := 0             // return to waiting state
        pop r1 off stack r2
        goto calculator

.section init
m[r0][jumptable + '+'] := add
.section text
add:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for add fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    r4 := r5 + r4               // calculate x + y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + '-'] := subtract
.section text
subtract:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for subtract fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    r4 := r5 - r4               // calculate x - y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + '*'] := multiply
.section text
multiply:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for multiply fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    r4 := r5 * r4               // calculate x * y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + '/'] := divide
.section text
division_by_zero:
    push r4 on stack r3             // return 0 to value stack
    output "Division by zero\n"     
    pop r4 off stack r2             // restore nonvolatile registers
    pop r1 off stack r2
    goto calculator

negate_both:
    r4 := -r4
    r5 := -r5
    goto divide_continue

negate_r4:
    if (r5 <s 0) goto negate_both using r1
    goto divide_with_signed

divide_with_signed:
    if (r4 >s 0) goto skip_r4_negation using r1
    r4 := -r4
    skip_r4_negation:
    if (r5 >s 0) goto skip_r5_negation using r1
    r5 := -r5
    skip_r5_negation:
    r4 := r5 / r4
    r4 := -r4
    push r4 on stack r3
    pop r4 off stack r2
    pop r1 off stack r2
    r4 := 0         // calculator enters the waiting stage
    goto calculator

divide:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for divide fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    if (r4 == 0) goto division_by_zero
    pop r5 off stack r3         // pop x
    if (r4 <s 0) goto negate_r4 using r1
    if (r5 <s 0) goto divide_with_signed using r1
    
    divide_continue:
    r4 := r5 / r4               // calculate x / y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    pop r1 off stack r2
    r4 := 0         // calculator enters the waiting stage
    goto calculator


.section init
m[r0][jumptable + '|'] := or
.section text
or:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for or fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    r4 := r5 | r4               // calculate x | y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator  

.section init
m[r0][jumptable + '&'] := and
.section text
and:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for and fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    r4 := r5 & r4               // calculate x & y
    push r4 on stack r3         // push new value

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + 'c'] := negate
.section text
negate:
    push r1 on stack r2

    r5 := 1                     // number of elements required for negate fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r5
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r5 off stack r3         // pop x

    r5 := -r5                   // calculate -x
    push r5 on stack r3         // push new value

    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator


.section init
m[r0][jumptable + '~'] := complement
.section text
complement:
    push r1 on stack r2

    r5 := 1                     // number of elements required for complement fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r5
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r5 off stack r3         // pop x

    r5 := ~r5                   // calculate ~x
    push r5 on stack r3         // push new value

    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + 's'] := swap
.section text
swap:
    push r1 on stack r2
    push r4 on stack r2         

    r5 := 2                     // number of elements required for and fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r4
    r5 := r3 + 1
    if (r5 == value_stack) goto stack_underflow using r4
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r4 off stack r3         // pop y
    pop r5 off stack r3         // pop x

    push r4 on stack r3         // reversing order of x and y on value stack
    push r5 on stack r3

    pop r4 off stack r2         // restore nonvolatile values
    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + 'd'] := duplicate
.section text
duplicate:
    push r1 on stack r2

    r5 := 1                     // number of elements required for complement fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r5
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r5 off stack r3         // pop x
    
    push r5 on stack r3         // duplicating value on stack
    push r5 on stack r3         

    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + 'p'] := pop_value
.section text
pop_value:
    push r1 on stack r2

    r5 := 1                     // number of elements required for complement fn
    push r5 on stack r2         // passing to stack_underflow
    if (r3 == value_stack) goto stack_underflow using r5
    pop r5 off stack r2         // removing from call stack if sufficient args
    
    pop r5 off stack r3         // pop x 

    r4 := 0         // calculator enters the waiting stage
    pop r1 off stack r2
    goto calculator

.section init
m[r0][jumptable + 'z'] := clear
.section text
clear:
    if (r3 == value_stack) goto calculator using r5
    pop r5 off stack r3
    r4 := 0         // calculator enters the waiting stage
    
    goto clear

.section text
digit:
    if (r4 == 0) goto digit_waiting
    pop r5 off stack r3     // getting digit to "enter"
    r5 := r5 * 10           // adjusting to add new input
    pop r4 off stack r2
    r4 := r4 - 48
    r5 := r4 + r5
    push r5 on stack r3     // value to be added to value stack
    r4 := 1
    goto calculator

digit_waiting:
    pop r5 off stack r2     // parameter
    r5 := r5 - 48
    push r5 on stack r3     // Adding to call stack
    r4 := 1
    goto calculator

.section text
stack_underflow:
    pop r5 off stack r2     // retrieving number of arguments
    output "Stack underflow---expected at least "
    output r5 + 48
    output " elements\n"
    pop r4 off stack r2
    pop r1 off stack r2
    r4 := 0
    goto calculator

input_err:
    pop r5 off stack r2
    output "Unknown character '"
    output r5
    output "'\n"

.section text
main:
    .section valstk
        .space 10000
        value_stack:
    
    .section text
    r3 := value_stack
    // 0 is waiting and 1 is entering
    r4 := 0                 // Initial state is waiting

calculator:
    r5 := input()
    r5 := ~r5
    if (r5 == 0) goto r1
    r5 := ~r5
    
    push r5 on stack r2         // push input value on the stack
    r5 := jumptable + r5
    r5 := m[r0][r5]
    goto r5
